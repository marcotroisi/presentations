---
title: Why You Should Build Your Next Product With AppSync
description: 
author: Marco Troisi
keywords: appsync,aws community day
url: https://marcotroisi.com
---

<!-- Global style -->
<style>
h1,h2,h3,h4 {
  color: #213466;
  text-align: left;
  font-family: 'CaskaydiaCove NF', serif;
}
section.lead h2, section.lead h3 {
  text-align: center;
}
h2 {
  font-size: 58px;
}
h1 {
  font-size: 84px;
  font-weight: 700;
  text-align: center;
}
p {
  font-family: 'Aptos', serif;
}
img[alt~="center"] {
  display: block;
  margin: 0 auto;
}
</style>


<!-- backgroundImage: "linear-gradient(to bottom, #ffffff, #EBEFFC)" -->
<!-- _class: lead -->

![bg left:33%](https://upload.wikimedia.org/wikipedia/commons/c/c6/Swiss_army_knife_open_20050612.jpg)

# Why You Should Build Your Next Product With AppSync
### Marco Troisi
![height:80px center](aws_community_day_logo.png)

---
<!-- footer: Marco Troisi ‚Ä¢ Why You Should Build Your Next Product With AppSync -->
<!-- paginate: true -->
<!-- backgroundImage: none -->

## Hello there!

- Marco Troisi
- Born in üáÆüáπ Living in üá¨üáß
- CTO at Trilo
- Software Developer and Software Architect for over 12 years
- AWS Community Builder (Serverless)
- Writer for The Serverless Mindset newsletter

![companies center height:100px](https://raw.githubusercontent.com/marcotroisi/presentations/main/decks/why-you-should-use-appsync/companies_logos.png)

---

## Agenda

- The evolution of AppSync
- *Reason #1*: Rapid Prototyping
- *Reason #2*: Infinite Scalability
- *Reason #3*: Team Collaboration
- *Reason #4*: Native AWS Integration
- *Reason #5*: Error Reduction
- *Reason #6*: Cloud-Native Evolution
- *Reason #7*: Empowering Small Teams

---

## The evolution of AppSync

- The old AppSync 
  - VT-*hell*
  - Not so great DX
  - Business logic very hard to test

![bg right:45%](appsync_launch.png)

---

## The evolution of AppSync

- The *new* AppSync 
  - Javascript resolvers
  - Lambda resolvers
  - Direct connections

![bg right:45%](js_resolver_code.png)

---

# Rapid Prototyping

1. Build a UI
2. Write the interactions in GraphQL
3. Figure out the AWS services needed
4. Write the resolvers
5. Amplify codegen
6. Good to go üéâ

---

# Infinite Scalability

- Automatic scaling
- 100% serverless
- Real-time data sync
- IAM authentication
- Multi-region support

---

# Team Collaboration

- GraphQL as a shared language between frontend and backend
- Reduce misunderstandings
- Parallelise work

---

# Native AWS Integrations

- Easy to connect *directly* to AWS services
- No need for glue code

---

# Error Reduction

- Less reliance on custom code
- Fewer potential points of failure
- Less boilerplate

---

# Cloud-Native Evolution

- The convenience of Django, Rails, Laravel
- ...but backed by the cloud!

(AppSync is not a battery-included framework)

---

# Empowering Small Teams

- We rebuilt our entire API layer in a few weeks
- Made us much more productive and able to parallelise our work
- Has given us clarity over our data access patterns
- Has made it easier for frontend people to venture into the backend

---

<!-- 
paginate: false 
footer: ""
-->

![bg](trilo_arch.png)

---

# Thank You! üôè

---

<!-- paginate: false -->

## Useful Links

![](useful_links.png)


